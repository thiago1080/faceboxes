import numpy as np
import cv2 

#legenda:
#		rectangle: a list with four float elements, representing the coordinate of a rectangle, commonly in y1, x1, y2, x2 format.
# 		detection: a rectangle generated by the detector.
#		AP (Average Precision): Maximum precision for recall equal or greater.

class map():
	

	def init(self):
		pass

	def tofloat(self,lines):
		#input: a list with lines readed from groundtruth file.
		#output: an ordered dictionary whose values are all input  strings casted to float
		k2 = {}
		for c,j in enumerate(lines):
			i3=[]
			for x in j.split():
				x = float(x)
				i3.append(x)
			k2[c] = i3
		return k2

	def tofloat2(self,lines):
		#input: a list with lines readed from groundtruth file.
		#output: a list with all input  strings casted to float
		k2 = {}
		ret = []
		for c, j in enumerate(lines):
			i3=[]
			for c2, x in enumerate(j.split()):
				if c2 > 3:
					break
				x = float(x)
				i3.append(x)
			k2[c] = i3
		for j in k2.values():
			ret.append(j)
		return ret


	def toyxyx(self, k2):
		#input: a list of a rectangle [x, y, width, height]
		#output: a list of a rectangle [y1, x1, y2, x2]
		y = [] 
		for c,i in enumerate(k2):
			rect = i
			r2 = [None, None, None, None]
			r2[0] = rect[1]
			r2[1] = rect[0]
			r2[2] = rect[1]+rect[3]
			r2[3] = rect[0]+rect[2]
			y.append(r2)
		return y




	def inter(self, ret1, ret2):
		#input:  two lists with four values each. The values are the coordinates of a rectangle.
		#output: the area of intersecition of the rectangles. 
		return (min(ret2[3],ret1[3])- max(ret2[1],ret1[1])) * (min(ret2[2],ret1[2]) - max(ret2[0],ret1[0]))

	def find_match(self, rect, rects):
		#Finds the greatest intersection between ret and a list of rectangules rets
		#input: 
		#		rect: a list with four float values representing coordinates of a rectangle.
		#		rects: a list of lists (rects).
		#output:
		#		maxinte: the value of the maximum intersection
		#		the index of the rect from the input rects, that presenst maximum intersection with the input rect.
		i = rect
		c = -1
		match = None
		maxinte = 0
		for igt in rects:
			c += 1
			if i[0] > igt[2]:
				continue
			if i[2] < igt[0]:
				continue
			if i[1] > igt[3]:
				continue
			if i[3] < igt[1]:
				continue
			inte = self.inter(i,igt)
			if inte > maxinte:
				maxinte = inte
				match = c	
		return [maxinte, match]

	def find_match2(self, list1, list2):
		#input: two lists of rects.
		#output: a dictionary relating the indexes of matching rects from the two input lists
		c = 0
		maxinte = 0
		matches = {}
		for i in list1:
			inte, match2 = self.find_match(i, list2)
			matches[c] = match2
			#print('maches: {}, c : {}, inte: {}'.format(matches, c, inte))
			c += 1
		return matches
		
	def find_match3(self, list1, list2):
		#input: two lists of rects.
		#output: a list whose elements are lists of two integers, representing the indexes of matching rects from the two input lists.
		
		c = 0
		maxinte = 0
		pair = []
		matches =[]
		for i in list1:
			inte, match2 = self.find_match(i, list2)
			pair = [c, match2]
			matches.append(pair)
			#print('maches: {}, c : {}, inte: {}'.format(matches, c, inte))
			c += 1
		return matches

	def area(self, rect):
		return (rect[2] - rect[0]) * (rect[3] - rect[1])

	def union(self, rect1, rect2):
		return self.area(rect1) + self.area(rect2) - self.inter(rect1, rect2)

	def iou(self, rect1, rect2):
		return self.inter(rect1, rect2) / self.union(rect1, rect2)

	def positive(self,rect1, rect2):
		if self.iou(rect1,rect2) > 0.5:
			return 1
		else:
			return 0

	def analysis(self, det, gt, dic):

		#input:
		#	det: a list of  detections.
		#	gt: a rectangle readed from the groundtruth file.
		#   dic: a dictionary relating the indexes from the corresponding rectangles from det and gt.
		#output:
		#	l1: a list of positive results in dets (used later to compute recall)
		#	l2: a list of positive results in gt(used later to compute precision)

		l1 = np.zeros(len(det))
		l2 = np.zeros(len(gt))
		for i in dic:
			if dic[i] is not None:
				a = self.positive(det[i], gt[dic[i]])
				l1[i] = a
				l2[dic[i]] = a
		return l1, l2

	def analysis2(self, det, gt, matches):

		#input:
		#	det: a list of  detections.
		#	gt: a rectangle readed from the groundtruth file.
		#   matches: a list whose elements are lists of two integer, that relate the indexes from the corresponding rectangles from det and gt.
		#output:
		#	l1: a list of positive results in dets (used later to compute recall)
		#	l2: a list of positive results in gt(used later to compute precision)
			l1 = np.zeros(len(det))
			l2 = np.zeros(len(gt))
			for c, j in enumerate(matches):
				if j[0] != None and j[1] != None:
					a = self.positive(det[j[0]], gt[j[1]])
					l1[j[0]] = a
					l2[j[1]] = a
			return l1, l2

	def prec_rec(self, l1, l2):
		#input: lists generated by methods analysis or analysis2.
		#output: precisions (float). recall (float). Number of values in list l1 (or l2, they have the same size)
		if len(l1) == 0 or len(l2) ==0:
			return 0, 0, len(l2)
		precision = sum(l1)/len(l1)
		recall = sum(l2)/len(l2)
		return precision, recall , len(l2)
	
	def mAp(self, precs):
		#input: a list of precision values for different thresholds.
		#output: a list of AP (average precision)
		pmax = 0
		mapPrecs = [None] * (len(precs))
		for c, i in enumerate(reversed(precs)):
			if i > pmax:
				pmax = i
			mapPrecs[len(precs) - 1 -c] = pmax
		return mapPrecs , len(precs)
				
	def embed_gr(self,fd, image, tr=0.5):
		#input: 
		#	image: path to image file.
		#	tr: threshold.
			#output:
			#	list of detections.
			img = cv2.imread(image)
			height, width, c = img.shape
			img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
			detections = fd.detect(img, threshold=tr)
			dets = []
			for detection in detections:
				y1 = detection.top * height
				x1 = detection.left * width
				y2 = (detection.top + detection.height) * height
				x2 = (detection.left + detection.width) * width
				dets.append([y1, x1, y2 ,x2])
			return dets

	def det2yx(self,detection,img):
		height, width, c = img.shape
		y1 = detection.top * height
		x1 = detection.left * width
		y2 = (detection.top + detection.height) * height
		x2 = (detection.left + detection.width) * width
		return [y1, x1, y2 ,x2]


	def embed_fb(self,fd, image, tr=0.5):
		#input: 
		#	image: path to image file.
		#	tr: threshold.
		#output:
		#	boxes: list of detections.
		#	score: score of detections.
		img = cv2.imread(image)
		img = cv2.imread(image)
		img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
		boxes, scores = fd(img, score_threshold=tr)
		return boxes, scores

	def mediap(self, precs, numbers):
		#calcula a média ponderada.
		#input: 
		#	precs: a list of values (precisions)
		#	numbers: a list of weights for these values.
		#ouput: média ponderada dos values.
		soma = 0 
		for c, i in enumerate(numbers):
			soma += i
			precs[c] = precs[c] * i 
		if soma == 0: return 0
		med = sum(precs) / soma
		return med
	
	def det_to_yxyx(self, detection):
		#input: a detection object (from gryfo)
		#output:a list in format y,x,y,x
		y1 = detection.top
		x1 = detection.left
		y2 = y1 + detection.height
		x2 = x1 + detection.width	
		return [y1, x1, y2 ,x2]
	
	def gf_generic_detect(self, gd, image_path, tr = None):
		img = cv2.imread(image_path)
		img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
		dets = gd.detect(img, threshold=tr)
		rets = []
		for det in dets:
			ret = self.det2yx(det,img)
			rets.append(ret)
		print(rets)
		return rets

